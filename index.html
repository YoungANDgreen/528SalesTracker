<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sales Galaxy Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a1a;
            font-family: 'Poppins', sans-serif;
            color: #e0e0e0;
            overflow: hidden;
        }
        #scene-container {
            width: 75vw;
            height: 100vh;
            position: absolute;
            left: 0;
        }
        #fileInput {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00d4ff;
            border-radius: 5px;
            color: #fff;
        }
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 20;
            display: none;
        }
        #charts-sidebar {
            position: absolute;
            right: 0;
            top: 0;
            width: 25vw;
            height: 100vh;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            overflow-y: auto;
            z-index: 10;
        }
        .chart-box {
            margin-bottom: 20px;
        }
        .chart-box h3 {
            margin: 0 0 10px;
            color: #00d4ff;
            font-size: 1.2em;
        }
        .chart-box svg {
            width: 100%;
            height: 260px;
        }
    </style>
</head>
<body>
    <input type="file" id="fileInput" accept=".txt" />
    <div id="scene-container"></div>
    <div id="tooltip"></div>
    <div id="charts-sidebar"></div>

    <script>
        if (typeof THREE === 'undefined') {
            console.error('Three.js failed to load. Attempting fallback...');
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/three@0.134.0/build/three.min.js';
            script.onload = init;
            document.head.appendChild(script);
        } else {
            init();
        }

        function init() {
            const salesGoals = {
                LOCSEA: 1300000,
                ROBTAY: 1900000,
                MCISAM: 600000,
                ENCMIG: 200000,
            };

            const chartLabels = Object.keys(salesGoals);
            const salesData = [0, 0, 0, 0];
            const goalData = Object.values(salesGoals);
            const totalGoal = goalData.reduce((sum, val) => sum + val, 0);

            // Three.js Setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth * 0.75 / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth * 0.75, window.innerHeight);
            document.getElementById('scene-container').appendChild(renderer.domElement);

            // Background Stars
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                starVertices.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            // Nebula
            const nebulaGeometry = new THREE.BufferGeometry();
            const nebulaMaterial = new THREE.PointsMaterial({ color: 0x00d4ff, size: 2, transparent: true, opacity: 0.3 });
            const nebulaVertices = [];
            for (let i = 0; i < 500; i++) {
                nebulaVertices.push((Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000);
            }
            nebulaGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nebulaVertices, 3));
            const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
            scene.add(nebula);

            // Central Hub
            const hubGeometry = new THREE.SphereGeometry(5, 32, 32);
            const hubMaterial = new THREE.MeshBasicMaterial({ color: 0x00d4ff });
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            scene.add(hub);

            // Planets (Sprites with Faces) and Rings
            const planets = [];
            const rings = [];
            const positions = [
                { x: -40, y: 25, z: -20 }, // LOCSEA
                { x: 40, y: 23, z: -15 },  // ROBTAY
                { x: -35, y: -25, z: -20 }, // MCISAM
                { x: 35, y: -45, z: -35 }  // ENCMIG
            ];
            const faceTextures = [
                'trump.jpeg', // Replace with your PNG paths or URLs
                'puff.jpeg',
                'luna.jpeg',
                'poptart.jpeg'
            ];
            const loader = new THREE.TextureLoader();
            chartLabels.forEach((name, index) => {
                const texture = loader.load(faceTextures[index]);
                const planetMaterial = new THREE.SpriteMaterial({ map: texture });
                const planet = new THREE.Sprite(planetMaterial);
                planet.scale.set(25, 25, 3); // Size of the face
                planet.position.set(positions[index].x, positions[index].y, positions[index].z);
                planet.userData = { name, sales: 0, goal: goalData[index], index };
                scene.add(planet);
                planets.push(planet);

                const ringGeometry = new THREE.TorusGeometry(21, 0.6, 48, 100);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xff007a, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.position.copy(planet.position);
                scene.add(ring);
                rings.push(ring);

                // Glowing Trail
                // const trailGeometry = new THREE.BufferGeometry();
                // const trailMaterial = new THREE.PointsMaterial({ color: 0x00d4ff, size: 0.3, transparent: true, opacity: 0.5 });
                // const trailVertices = [];
                // for (let i = 0; i < 50; i++) {
                //     trailVertices.push(planet.position.x + Math.sin(i * 0.1) * 5, planet.position.y + i * 0.2 - 5, planet.position.z);
                // }
                // trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailVertices, 3));
                // const trail = new THREE.Points(trailGeometry, trailMaterial);
                // scene.add(trail);
            });
            console.log(`Created ${planets.length} planets and ${rings.length} rings`);

            camera.position.set(0, 20, 60);
            camera.lookAt(0, 0, 0);

            // Animation Loop
            function animate() {
                requestAnimationFrame(animate);
                stars.rotation.y += 0.0005;
                nebula.rotation.y += 0.0002;
                hub.rotation.y += 0.005;
                gsap.to(hub.scale, { x: 1.1, y: 1.1, z: 1.1, duration: 1, yoyo: true, repeat: -1 });
                planets.forEach((planet, i) => {
                    rings[i].rotation.z += 0.005;
                });
                renderer.render(scene, camera);
            }
            animate();

            // Persistent Charts
            function updateCharts() {
                const sidebar = d3.select('#charts-sidebar').html('');
                chartLabels.forEach((name, i) => {
                    const chartBox = sidebar.append('div').attr('class', 'chart-box');
                    chartBox.append('h3').text(name);
                    const svg = chartBox.append('svg').attr('id', `chart-${name}`);
                    const width = 300;
                    const height = 250;
                    const margin = { top: 10, right: 10, bottom: 15, left: 40 };

                    const x = d3.scaleLinear().domain([0, 12]).range([margin.left, width - margin.right]);
                    const y = d3.scaleLinear().domain([0, goalData[i] * 1.2]).range([height - margin.bottom, margin.top]);

                    svg.append('g')
                        .attr('transform', `translate(0,${height - margin.bottom})`)
                        .call(d3.axisBottom(x).ticks(5));
                    svg.append('g')
                        .attr('transform', `translate(${margin.left},0)`)
                        .call(d3.axisLeft(y).tickFormat(d => `$${d / 1000}k`));

                    const line = d3.line()
                        .x((d, i) => x(i))
                        .y(d => y(d))
                        .curve(d3.curveMonotoneX);

                    const pathData = [0, salesData[i] / 2, salesData[i]];
                    const path = svg.append('path')
                        .datum(pathData)
                        .attr('fill', 'none')
                        .attr('stroke', '#ff007a')
                        .attr('stroke-width', 2)
                        .attr('d', line);

                    const totalLength = path.node().getTotalLength();
                    path.attr('stroke-dasharray', `${totalLength} ${totalLength}`)
                        .attr('stroke-dashoffset', totalLength)
                        .transition()
                        .duration(1000)
                        .ease(d3.easeLinear)
                        .attr('stroke-dashoffset', 0);
                });
            }
            updateCharts();

            // Custom PNG Confetti Explosion
            function explodePlanet(planet) {
                const confettiTexture = loader.load('confetti.png'); // Replace with your PNG path or URL
                const confettiMaterial = new THREE.SpriteMaterial({ map: confettiTexture });
                const confettiParticles = [];
                for (let i = 0; i < 50; i++) {
                    const sprite = new THREE.Sprite(confettiMaterial);
                    sprite.scale.set(1, 1, 1);
                    sprite.position.copy(planet.position);
                    scene.add(sprite);
                    confettiParticles.push(sprite);

                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = Math.random() * 10;
                    gsap.to(sprite.position, {
                        x: planet.position.x + r * Math.sin(phi) * Math.cos(theta),
                        y: planet.position.y + r * Math.sin(phi) * Math.sin(theta),
                        z: planet.position.z + r * Math.cos(phi),
                        duration: 2,
                        onComplete: () => scene.remove(sprite)
                    });
                    gsap.to(sprite.scale, { x: 0, y: 0, z: 0, duration: 2 });
                }
            }

            // Raycaster for Interactivity
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let selectedPlanet = null;

            window.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX / (window.innerWidth * 0.75)) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(planets);
                const tooltip = document.getElementById('tooltip');
                if (intersects.length > 0) {
                    const planet = intersects[0].object;
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${event.clientX + 10}px`;
                    tooltip.style.top = `${event.clientY + 10}px`;
                    tooltip.innerHTML = `
                        <strong>${planet.userData.name}</strong><br>
                        Sales: $${planet.userData.sales.toLocaleString()}<br>
                        Goal: $${planet.userData.goal.toLocaleString()}<br>
                        Progress: ${(planet.userData.sales / planet.userData.goal * 100).toFixed(1)}%
                    `;
                } else {
                    tooltip.style.display = 'none';
                }
            });

            window.addEventListener('click', (event) => {
                mouse.x = (event.clientX / (window.innerWidth * 0.75)) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(planets);
                if (intersects.length > 0) {
                    const planet = intersects[0].object;
                    if (selectedPlanet !== planet) {
                        selectedPlanet = planet;
                        gsap.to(planet.scale, { x: 35, y: 35, z: 4, duration: 0.5 });
                        planets.forEach(p => { if (p !== planet) gsap.to(p.scale, { x: 10, y: 10, z: 1, duration: 0.5 }); });
                        const percentage = planet.userData.sales / planet.userData.goal * 100;
                        if (percentage >= 100) {
                            explodePlanet(planet);
                        } else {
                            gsap.to(rings[planet.userData.index].scale, { x: 1.2, y: 1.2, z: 1, duration: 0.5, yoyo: true, repeat: 1 });
                        }
                    }
                }
            });

            // File Upload Handler
            document.getElementById('fileInput').addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    const content = e.target.result;
                    const lines = content.split('\n').filter((line) => line.trim() !== '');
                    const columnDefinitions = [
                        { start: 0, length: 5 },
                        { start: 6, length: 11 },
                        { start: 19, length: 10 },
                        { start: 30, length: 51 },
                        { start: 83, length: 11 },
                    ];

                    const parsedData = lines.map((line) => {
                        const entry = {};
                        columnDefinitions.forEach((col, index) => {
                            entry[`col${index + 1}`] = line.substr(col.start, col.length).trim();
                        });
                        return entry;
                    });

                    const salesSummary = {};
                    parsedData.forEach((entry) => {
                        const name = entry.col2;
                        const amount = parseFloat(entry.col5);
                        if (!salesSummary[name]) salesSummary[name] = 0;
                        salesSummary[name] += amount;
                    });

                    if (salesSummary['LOCROB']) {
                        const locrobAmount = salesSummary['LOCROB'] / 2;
                        salesSummary['ROBTAY'] = (salesSummary['ROBTAY'] || 0) + locrobAmount;
                        salesSummary['LOCSEA'] = (salesSummary['LOCSEA'] || 0) + locrobAmount;
                    }

                    salesData[0] = salesSummary['LOCSEA'] || 0;
                    salesData[1] = salesSummary['ROBTAY'] || 0;
                    salesData[2] = salesSummary['MCISAM'] || 0;
                    salesData[3] = salesSummary['ENCMIG'] || 0;

                    console.log('Sales Data:', salesData);

                    // Update Visuals
                    planets.forEach((planet, i) => {
                        planet.userData.sales = salesData[i];
                        const percentage = Math.min((salesData[i] / goalData[i]) * 100, 100);
                        gsap.to(rings[i].scale, { x: percentage / 100, y: percentage / 100, z: 1, duration: 1 });
                        if (percentage >= 100) explodePlanet(planet);
                        console.log(`Planet ${planet.userData.name}: Sales=${salesData[i]}, Goal=${goalData[i]}, Percentage=${percentage}%`);
                    });
                    updateCharts();
                };
                reader.readAsText(file);
            });

            // Resize Handler
            window.addEventListener('resize', () => {
                camera.aspect = (window.innerWidth * 0.75) / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth * 0.75, window.innerHeight);
            });
        }
    </script>
</body>
</html>
