<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sales Galaxy Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a1a;
            font-family: 'Poppins', sans-serif;
            color: #e0e0e0;
            overflow: hidden;
        }
        #scene-container {
            width: 75vw;
            height: 100vh;
            position: absolute;
            left: 0;
        }
        #fileInput {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00d4ff;
            border-radius: 5px;
            color: #fff;
        }
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 20;
            display: none;
        }
        #charts-sidebar {
            position: absolute;
            right: 0;
            top: 0;
            width: 25vw;
            height: 100vh;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            overflow-y: auto;
            z-index: 10;
        }
        .chart-box {
            margin-bottom: 20px;
        }
        .chart-box h3 {
            margin: 0 0 10px;
            color: #00d4ff;
            font-size: 1.2em;
        }
        .chart-box svg {
            width: 100%;
            height: 350px;
        }
    </style>
</head>
<body>
    <input type="file" id="fileInput" accept=".txt" />
    <div id="scene-container"></div>
    <div id="tooltip"></div>
    <div id="charts-sidebar"></div>

    <script>
        if (typeof THREE === 'undefined') {
            console.error('Three.js failed to load. Attempting fallback...');
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/three@0.134.0/build/three.min.js';
            script.onload = init;
            document.head.appendChild(script);
        } else {
            init();
        }

        function init() {
            const salesGoals = {
                LOCSEA: 1600000,
                ROBTAY: 2000000,
                MCISAM: 500000,
                ENCMIG: 100000,
            };

            const chartLabels = Object.keys(salesGoals);
            const salesData = [0, 0, 0, 0];
            const goalData = Object.values(salesGoals);
            const totalGoal = goalData.reduce((sum, val) => sum + val, 0);

            // Three.js Setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth * 0.75 / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth * 0.75, window.innerHeight);
            document.getElementById('scene-container').appendChild(renderer.domElement);

            // Background Stars
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                starVertices.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            // Nebula
            const nebulaGeometry = new THREE.BufferGeometry();
            const nebulaMaterial = new THREE.PointsMaterial({ color: 0x00d4ff, size: 2, transparent: true, opacity: 0.3 });
            const nebulaVertices = [];
            for (let i = 0; i < 500; i++) {
                nebulaVertices.push((Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000);
            }
            nebulaGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nebulaVertices, 3));
            const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
            scene.add(nebula);

            // Central Hub
            const hubGeometry = new THREE.SphereGeometry(5, 32, 32);
            const hubMaterial = new THREE.MeshBasicMaterial({ color: 0x00d4ff });
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            scene.add(hub);

            // Planets and Rings
            const planets = [];
            const rings = [];
            chartLabels.forEach((name, index) => {
                const angle = (index / chartLabels.length) * Math.PI * 2;
                const radius = 20 + index * 5;
                const planetGeometry = new THREE.SphereGeometry(2, 32, 32);
                const planetMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                planet.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius - 10);
                planet.userData = { name, sales: 0, goal: goalData[index] };
                scene.add(planet);
                planets.push(planet);

                const ringGeometry = new THREE.TorusGeometry(radius + 2, 0.2, 16, 100);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xff007a, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.position.z = -10;
                scene.add(ring);
                rings.push(ring);
            });

            camera.position.z = 50;

            // Animation Loop
            function animate() {
                requestAnimationFrame(animate);
                stars.rotation.y += 0.0005;
                nebula.rotation.y += 0.0002;
                gsap.to(hub.scale, { x: 1.1, y: 1.1, z: 1.1, duration: 1, yoyo: true, repeat: -1 });
                planets.forEach((planet, i) => {
                    planet.rotation.y += 0.01;
                    rings[i].rotation.z += 0.005;
                });
                renderer.render(scene, camera);
            }
            animate();

            // Persistent Charts
            function updateCharts() {
                const sidebar = d3.select('#charts-sidebar').html('');
                chartLabels.forEach((name, i) => {
                    const chartBox = sidebar.append('div').attr('class', 'chart-box');
                    chartBox.append('h3').text(name);
                    const svg = chartBox.append('svg').attr('id', `chart-${name}`);
                    const width = 300;
                    const height = 250;
                    const margin = { top: 10, right: 10, bottom: 20, left: 20 };

                    const x = d3.scaleLinear().domain([0, 4]).range([margin.left, width - margin.right]);
                    const y = d3.scaleLinear().domain([0, goalData[i] * 1.2]).range([height - margin.bottom, margin.top]);

                    svg.append('g')
                        .attr('transform', `translate(0,${height - margin.bottom})`)
                        .call(d3.axisBottom(x).ticks(5));
                    svg.append('g')
                        .attr('transform', `translate(${margin.left},0)`)
                        .call(d3.axisLeft(y).tickFormat(d => `$${d / 1000}k`));

                    const line = d3.line()
                        .x((d, i) => x(i))
                        .y(d => y(d))
                        .curve(d3.curveMonotoneX);

                    const pathData = [0, salesData[i] / 2, salesData[i]]; // Simulated trend
                    const path = svg.append('path')
                        .datum(pathData)
                        .attr('fill', 'none')
                        .attr('stroke', '#ff007a')
                        .attr('stroke-width', 2)
                        .attr('d', line);

                    const totalLength = path.node().getTotalLength();
                    path.attr('stroke-dasharray', `${totalLength} ${totalLength}`)
                        .attr('stroke-dashoffset', totalLength)
                        .transition()
                        .duration(1000)
                        .ease(d3.easeLinear)
                        .attr('stroke-dashoffset', 0);
                });
            }
            updateCharts(); // Initial render

            // Particle Explosion for Goal Hit
            function explodePlanet(planet) {
                const particleGeometry = new THREE.BufferGeometry();
                const particleMaterial = new THREE.PointsMaterial({ color: 0xffff00, size: 0.5 });
                const particleVertices = [];
                for (let i = 0; i < 200; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = Math.random() * 5;
                    particleVertices.push(
                        planet.position.x + r * Math.sin(phi) * Math.cos(theta),
                        planet.position.y + r * Math.sin(phi) * Math.sin(theta),
                        planet.position.z + r * Math.cos(phi)
                    );
                }
                particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
                const particles = new THREE.Points(particleGeometry, particleMaterial);
                scene.add(particles);

                gsap.to(particles.position, {
                    x: '+=10',
                    y: '+=10',
                    z: '+=10',
                    duration: 2,
                    onComplete: () => scene.remove(particles)
                });
                gsap.to(particles.material, { opacity: 0, duration: 2 });
            }

            // Raycaster for Interactivity
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let selectedPlanet = null;

            window.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX / (window.innerWidth * 0.75)) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(planets);
                const tooltip = document.getElementById('tooltip');
                if (intersects.length > 0) {
                    const planet = intersects[0].object;
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${event.clientX + 10}px`;
                    tooltip.style.top = `${event.clientY + 10}px`;
                    tooltip.innerHTML = `
                        <strong>${planet.userData.name}</strong><br>
                        Sales: $${planet.userData.sales.toLocaleString()}<br>
                        Goal: $${planet.userData.goal.toLocaleString()}<br>
                        Progress: ${(planet.userData.sales / planet.userData.goal * 100).toFixed(1)}%
                    `;
                } else {
                    tooltip.style.display = 'none';
                }
            });

            window.addEventListener('click', (event) => {
                mouse.x = (event.clientX / (window.innerWidth * 0.75)) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(planets);
                if (intersects.length > 0) {
                    const planet = intersects[0].object;
                    if (selectedPlanet !== planet) {
                        selectedPlanet = planet;
                        gsap.to(planet.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 0.5 });
                        planets.forEach(p => { if (p !== planet) gsap.to(p.scale, { x: 1, y: 1, z: 1, duration: 0.5 }); });
                        const percentage = planet.userData.sales / planet.userData.goal * 100;
                        if (percentage >= 50) {
                            explodePlanet(planet);
                            confetti({ particleCount: 5000, spread: 1000 });
                        } else if (percentage >= 100) {
                            explodePlanet(planet);
                            confetti({ particleCount: 20000, spread: 2000 });
                        } else {
                            gsap.to(rings[chartLabels.indexOf(planet.userData.name)], {
                                scale: { x: 1.2, y: 1.2, z: 1 },
                                duration: 0.5,
                                yoyo: true,
                                repeat: 1
                            });
                        }
                    }
                }
            });

            // File Upload Handler
            document.getElementById('fileInput').addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    const content = e.target.result;
                    const lines = content.split('\n').filter((line) => line.trim() !== '');
                    const columnDefinitions = [
                        { start: 0, length: 5 },
                        { start: 6, length: 11 }, // col2: Salesperson name
                        { start: 19, length: 10 },
                        { start: 30, length: 51 },
                        { start: 83, length: 11 }, // col5: Sales amount
                    ];

                    const parsedData = lines.map((line) => {
                        const entry = {};
                        columnDefinitions.forEach((col, index) => {
                            entry[`col${index + 1}`] = line.substr(col.start, col.length).trim();
                        });
                        return entry;
                    });

                    const salesSummary = {};
                    parsedData.forEach((entry) => {
                        const name = entry.col2;
                        const amount = parseFloat(entry.col5);
                        if (!salesSummary[name]) salesSummary[name] = 0;
                        salesSummary[name] += amount;
                    });

                    if (salesSummary['LOCROB']) {
                        const locrobAmount = salesSummary['LOCROB'] / 2;
                        salesSummary['ROBTAY'] = (salesSummary['ROBTAY'] || 0) + locrobAmount;
                        salesSummary['LOCSEA'] = (salesSummary['LOCSEA'] || 0) + locrobAmount;
                    }

                    salesData[0] = salesSummary['LOCSEA'] || 0;
                    salesData[1] = salesSummary['ROBTAY'] || 0;
                    salesData[2] = salesSummary['MCISAM'] || 0;
                    salesData[3] = salesSummary['ENCMIG'] || 0;

                    // Update Visuals
                    planets.forEach((planet, i) => {
                        planet.userData.sales = salesData[i];
                        const percentage = Math.min((salesData[i] / goalData[i]) * 100, 100);
                        planet.material.color.set(percentage >= 100 ? 0x00ff00 : percentage >= 75 ? 0xffff00 : 0xff0000);
                        gsap.to(rings[i].scale, { x: percentage / 100, y: percentage / 100, z: 1, duration: 1 });
                        if (percentage >= 100) confetti({ particleCount: 100, spread: 70 });
                    });
                    updateCharts();
                };
                reader.readAsText(file);
            });

            // Resize Handler
            window.addEventListener('resize', () => {
                camera.aspect = (window.innerWidth * 0.75) / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth * 0.75, window.innerHeight);
            });
        }
    </script>
</body>
</html>
